---
title: 'Spatial Data Manipulation, Analysis and Visualization in R: The Basics'
author: "Marc Weber"
date: "Wednesday, February 18 2015"
output:
  ioslides_presentation:
    fig_height: 9
    fig_width: 9
    keep_md: yes
logo: epa_seal.png
biglogo: epa_seal.png
widescreen: yes
---

## The Roadmap {.smallest .columns-2}
<div class="notes">
- I've been using R for about a decade, started doing spatial work in R about 5 years ago

- Impetus for doing spatial work in R was documenting workflow in same language most folks I work with use - R

- Now do about 50% or more of spatial work in R, but even when I don't use R, I really do use R - will explain later

- Talk will be a methods talk, not a demonstration of project, will go over a lot of foundation stuff many people may already know or have heard, but will hopefully have some interesting stuff later in talk even for those used to doing spatial work in R
</div>
- Structure of spatial data in R
- Reading / Writing Spatial Data
- Visualizing Spatial Data
- Analysing Spatial Data
- Tools, Tips, Resources
<img src="roadmap.jpg" alt="Roadmap" style="width: 400px;"/>

## Explosion of Spatial Packages in R Recently
<div class="centered">
```{r fig.width=7, fig.height=4, echo=FALSE}
library(png)
library(grid)
img <- readPNG('SpatialPackages.png')
 grid.raster(img)
```
</div>

- Spatial package dependencies on sp package in R (July 2011) from Roger Bivand talk
http://geostat-course.org/system/files/monday_slides.pdf 

## Get to know sp
<div class="notes">
- sp package is foundation for spatial objects in R, used by most spatial classes

- Key point is that sp uses S4 new style classes 

- S4 classes have formal definitions for components, or slots, that classes contain 

- very useful for spatial objects (i.e. bounding boxes have to have x and y mins an maxes, spatial things have to use CRS, ets)
</div>
<div class="centered">
```{r fig.width=8, fig.height=5, echo=FALSE}
library(png)
library(grid)
img <- readPNG('SpatialObjects.png')
 grid.raster(img)
```
</div>

## sp slots mirror the structure of ESRI shapefiles
Mandatory Components                                       Optional Components
---------------------------------------------------------  -------------
.shp - actual geometry of feature                          .prj - CRS and projection info in WKT format
.shx - shapef index - binary file giving position index    .sbn and .sbx- spatial indexing files
.dbf - attribute information, stored in dBase IV format    .xml - metadata file

## Get to know sp objects {.smaller .columns-2}
<div class="notes">
- Remember that sp uses new style classes - the class of an object in R determines the method used

- Therefore, we can use plot and summary on sp spatial objects and get appropriate results
</div>
```{r, warning=FALSE, message=FALSE, out.width= '450px', comment=NA}
library(rgdal)
data(nor2k)
class(nor2k)
slotNames(nor2k)
plot(nor2k, axes=T, main='Peaks in Norway over 2000 meters')
```

## Get to know sp objects {.smaller}
```{r, warning=FALSE, message=FALSE, comment=NA}
library(rgdal)
data(nor2k)
summary(nor2k)
```

## Get to know raster {.smallest .columns-2 .build}
<div class="notes">
- A big advantage of the raster package is that it can work with data on disk that's too large to load into memory for R

- raster package creates objects from files that only contain information about the structure of the data, like number of rows and columns, extent, but doesn't try to read all the cell values into memory

- Processes data in chunks when running computations on rasters
</div>
>- sp has spatial grid and pixel classes, but raster package is best for raster data in R
>- Raster data structure divides region into rectangles / cells 
>- Cells can store one or more values for the cells
```{r, message=FALSE,warning=FALSE, out.width= '450px'}
library(raster)
r <- raster(ncol=10, nrow=10)
values(r) <- c(1:100)
plot(r, main='Raster with 100 cells')
```

## Making data spatial {.smaller .build}
```{r, results='asis', out.width= '250px', message=FALSE, warning=FALSE, comment=NA}
library(maps);library(sp);require(knitr)
data(us.cities)
knitr::kable(us.cities[1:5,])
class(us.cities) # simple data frame
```

## Making data spatial {.smaller .build}
### Promote a data frame with coordinate to an sp SpatialPointsDataFrame
```{r, results='asis', out.width= '200px', message=FALSE, warning=FALSE, comment=NA,fig.align='center'}
library(maps);library(sp)
data(us.cities)
coordinates(us.cities) <- c("long", "lat") 
class(us.cities) 
plot(us.cities, pch = 20, col = 'forestgreen', axes=T,
     xlim=c(-125,-70), ylim=c(26,55))
```

## Maps package provides convenient stock maps {.smaller .columns-2}
```{r, message=FALSE, warning=FALSE, out.width= '275px'}
library(maps)
par(mfrow=c(1,1))
map()
map.text('county','oregon')
map.axes()
title(main="Oregon State")
```

Loading administrative backgrounds from Global Administrative Areas is another good option (http://gadm.org/)

## Dealing with coordinate reference systems in R {.smaller .columns-2}
* CRS can be geographic (lat/lon), projected, or NA in R
* Data with different CRS MUST be transformed to common CRS in R
* Projections in sp are provided in PROJ4 strings in the proj4string slot of an object
* http://www.spatialreference.org/

* Useful rgdal package functions:
    * projInfo(type='datum')
    * projInfo(type='ellps')
    * projInfo(type='proj')

<img src="CRS.png" alt="CRS" style="width: 550px;"/>


## Dealing with coordinate reference systems in R 
* For sp classes:
    * To get the CRS:  proj4string(x)
    * To assign the CRS:
        * Use either EPSG code or PROJ.4:
            * proj4string(x) <- CRS("init=epsg:4269")
            * proj4string(x) <- CRS("+proj=utm +zone=10 +datum=WGS84")
    * To transform CRS
          * x <- spTransform(x, CRS("+init=epsg:4238"))
          * x <- spTransform(x, proj4string(y))

* For rasters:
    * To get the CRS:  projection(x)
    * To transform CRS:  projectRaster(x)

## Reading and writing spatial data {.build}
- Best method for reading and writing shapefiles is to use readOGR() and writeOGR() in rgdal
```{r, eval=FALSE}
library(rgdal)
setwd('K:/GitProjects/RUserWebinar')
HUCs <- readOGR('.','OR_HUC08')
writeOGR(HUCs, '.','HUC', driver='ESRI Shapefile')
```
- Best method for reading and writing rasters is raster package
```{r, eval=FALSE}
library(raster)
r <- raster('clay.tif')
# crop it
r <- crop(r, extent(-1000000, 2000000, 100000, 3000000) )
writeRaster(r, 'clay_smaller.tif',format='GTiff')
```

## Understanding slot structure { .build}
```{r, eval=TRUE, echo=TRUE, comment=NA, message=FALSE, warning=FALSE}
require(sp);require(rgeos);load("K:/GitProjects/RUserWebinar/Data.RData")
# A spatial PolygonsDataFrame has 5 slots:
str(HUCs, 2)
```

## Understanding slot structure { .build}
```{r, eval=TRUE, echo=TRUE, comment=NA, message=FALSE, warning=FALSE}
require(sp);require(rgeos);load("K:/GitProjects/RUserWebinar/Data.RData")
# Each polygon element has 5 of it's own slots - here we look at first one:
str(HUCs@polygons[[1]])[]
```

## Understanding slot structure {.smaller .build}
```{r, eval=TRUE, echo=TRUE, comment=NA, message=FALSE, warning=FALSE}
require(sp);require(rgeos); load("K:/GitProjects/RUserWebinar/Data.RData")
# Here we get a vector of area for features in HUCs spdf
area(HUCs[1:4,])
# Total Area - gArea function in rgeos gives same result
sum(area(HUCs))
# Area of a particular feature
HUCs@polygons[[1]]@Polygons[[1]]@area
```

## Getting areas of polygons {.smaller .columns-2 .build}
```{r, eval=TRUE, echo=TRUE, comment=NA, out.width= '200px', message=FALSE, warning=FALSE}
require(sp);load("K:/GitProjects/RUserWebinar/Data.RData")
plot(HUCs, axes=T, main='HUCs in Oregon')
# just plot bigger HUCs
```
```{r, eval=TRUE, echo=TRUE, comment=NA, out.width= '200px', message=FALSE, warning=FALSE}
require(sp);load("K:/GitProjects/RUserWebinar/Data.RData")
plot(HUCs, axes=T, main='HUCs in Oregon')
# Function to calculate percent of area
AreaPercent <- function(x) {
  tot_area <- sum(sapply(slot(x, "polygons"),
                         slot, "area"))
  sapply(slot(x, "polygons"), slot, 
         "area") / tot_area * 100
}  
# just plot bigger HUCs
plot(HUCs[AreaPercent(HUCs) > 1,], add=T, 
     col='Steel Blue')
```

## Spatial Operations on vector data {.build .smaller .columns-2}
<div class="notes">
- First step in any spatial analysis should ALWAYS be setting everything to same CRS
- show code for how I found EPSG code for Oregon Lambert projection!
- Here we use ggplot to plot our gages and color the points by log of flow
</div>
```{r, echo=TRUE, message=FALSE, warning=FALSE, out.width= '400px'}
require(ggplot2);load("K:/GitProjects/RUserWebinar/Data.RData")
# Take a look at some USGS stream gages for PNW
gages@data[1:5,5:8]
# Explicitly set CRS for layers
gages <- spTransform(gages, CRS('+init=epsg:2991'))
# Locations of gages
ggplot(gages@data, aes(LON_SITE, LAT_SITE)) + 
  geom_point(aes(color=log10(AVE)))
```

## Spatial Operations on vector data {.build .smaller .columns-2}
### Spatial Indexing
```{r, echo=TRUE, message=FALSE, warning=FALSE, out.width= '200px'}
load("K:/GitProjects/RUserWebinar/Data.RData")
gages_proj <- spTransform(gages, CRS('+init=epsg:2991'))
HUCs_proj <- spTransform(HUCs, CRS('+init=epsg:2991'))
HUCs_proj$LON <- coordinates(HUCs_proj)[,1]
HUCs_west <- HUCs_proj[HUCs_proj$LON < 400000, ]
options(scipen=3)
plot(gages_proj, axes=T, col='blue')
plot(HUCs_west, add=T)
```

- Just index to subset spatially
```{r, echo=TRUE, message=FALSE, warning=FALSE, out.width= '300px'}
load("K:/GitProjects/RUserWebinar/Data.RData")
gages_west <- gages_proj[HUCs_west,]
plot(HUCs_west, axes=T)
plot(gages_west, add=T, col='blue')
```

## Spatial operations on vector data {.build}
### Dissolving
```{r, echo=FALSE, message=FALSE, warning=FALSE, out.width= '400px'}
library(rgeos); library(rgdal)
# Use gUnaryUnion from rgeos to dissolve polygons
# http://www.maths.lancs.ac.uk/~rowlings/Teaching/Sheffield2013/spatialops.html
#create four bins of longitude values using coordinate data from HUCs
lps <- coordinates(HUCs)
IDFourBins <- cut(lps[,1], quantile(lps[,1]), include.lowest=TRUE)
regions = gUnaryUnion(HUCs,IDFourBins)
regions = SpatialPolygonsDataFrame(regions,
                                   data.frame(regions = c('Coastal',
                                                          'Mountains',
                                                          'High Desert',
                                                          'Eastern')),
                                              match.ID = FALSE)
plot(regions, axes=T)
text(coordinates(regions), label = regions$regions, cex=.5)
```


## Spatial Operations on vector data
### Overlay and Aggregation
```{r, echo=TRUE, message=FALSE, , eval=FALSE,warning=FALSE}
load("K:/GitProjects/RUserWebinar/Data.RData")
# What regions are stream gages located in?
# We can use sp 'over' function to answer
# remember, must be same CRS!!!
proj4string()
gageHUCs <- over(gages,HUCs) # same as gages %over% HUCs

# simple function for updating our gages spatial data frame with
# result from over
OverUpdate <- function(points, polys) {
  pointpoly <- over(points, polys)
  points@data <- data.frame(points@data, pointpoly)
}

gages <- OverUpdate(gages, HUCs)
} 
head(gages@data)
```

## Attribute joining
```{r, echo=FALSE, message=FALSE, warning=FALSE}
load("K:/GitProjects/RUserWebinar/Data.RData")

# http://cran.r-project.org/doc/contrib/intro-spatial-rl.pdf
```

## Spdep
```{r, echo = FALSE, message=FALSE, warning=FALSE, eval=FALSE}
library(rgdal)
OR_HUCs <- readOGR('L:/Public/mweber/ORD_Geospatial_R','OR_HUC8')
require(spdep)
adj = poly2nb(OR_HUCs)
summary(adj)
```

## Demo knitr to run R and Python code snippets
```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(rgdal)
OR_HUCs <- readOGR('L:/Public/mweber/ORD_Geospatial_R','OR_HUC8')
plot(OR_HUCs, axes=T)
```


## Micromap Example like Brazil Murder Rate in SA Paper?

## Visualization - my runs perhaps? 
```{r, echo=FALSE, warning=FALSE, message=FALSE, eval=FALSE}
# http://spatial.ly/2012/02/great-maps-ggplot2/
```

## This type of visualizsation?
```{r, echo=TRUE, warning=FALSE, message=FALSE, eval=FALSE}
breaks = quantile(volcano, seq(0, 1, length.out=256))
cols = colorRampPalette(c("#55FFFF", "grey10"))(255)
par(mfrow = c(1, 2))
image(volcano, col=cols, axes=F, asp=T)
title(main = "Linear")
image(volcano, col=cols, breaks=breaks, axes=F, asp=T)
title(main = "Quantile")
```

## RGoogleMaps
```{r, echo=TRUE, warning=FALSE, message=FALSE, eval=FALSE}
```

## Point in poly example as in this example?
```{r, echo=TRUE, warning=FALSE, message=FALSE, eval=FALSE}
# http://www.maths.lancs.ac.uk/~rowlings/Teaching/Sheffield2013/spatialops.html
```

## Resources
- https://github.com/Robinlovelace/Creating-maps-in-R
- https://github.com/Pakillo/R-GIS-tutorial/blob/master/R-GIS_tutorial.md
- http://www.maths.lancs.ac.uk/~rowlings/Teaching/Sheffield2013/spatialops.html
- http://www.maths.lancs.ac.uk/~rowlings/Teaching/UseR2012/cheatsheet.html